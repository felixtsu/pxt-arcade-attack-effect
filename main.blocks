<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="lqYtd:|_ToiRNud*NPAG" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="a?5e%IK7^UyX#US/+XlM" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace attackEffect {" line1="" line2="    export enum LaserAttackDirection {" line3="        RIGHT," line4="        LEFT," line5="        UP," line6="        DOWN" line7="    }" line8="" line9="    const COLOR_INNER = 1" line10="    const COLOR_OUTER = 2" line11="" line12="    class LaserAttackCallback {" line13="        spriteKind: number" line14="        callback: (sprite: Sprite) =&gt; void" line15="        constructor(spriteKind: number, callback: (sprite: Sprite) =&gt; void) {" line16="            this.spriteKind = spriteKind;" line17="            this.callback = callback" line18="        }" line19="    }" line20="" line21="    class LaserAttackChecker {" line22="        private left: number" line23="        private right: number" line24="        private top: number" line25="        private bottom: number" line26="" line27="        private sprite: Sprite" line28="        private width: number" line29="        private direction: LaserAttackDirection" line30="" line31="        private active: boolean" line32="" line33="        private overlapCheckerImage: Image" line34="        private overlapCheckerImageCenterX: number" line35="        private overlapCheckerImageCenterY: number" line36="" line37="        private onHitCallbacks: LaserAttackCallback[]" line38="" line39="        private hitSprites :Sprite[]" line40="" line41="        define(sprite: Sprite, width: number, direction: LaserAttackDirection) {" line42="            this.active = true" line43="            this.sprite = sprite" line44="            this.width = width" line45="            this.direction = direction" line46="" line47="            // reset hit sprites every time" line48="            this.hitSprites = []" line49="        }" line50="" line51="        resetOverlapChecker() {" line52="            let result = null;" line53="            if (this.direction == LaserAttackDirection.RIGHT) {" line54="                this.left = this.sprite.x" line55="                this.right = 180" line56="                this.top = this.sprite.y - this.width / 2" line57="                this.bottom = this.sprite.y + this.width / 2" line58="" line59="                result = image.create(this.right - this.left, this.bottom - this.top)" line60="" line61="" line62="            }" line63="            result.fill(1)" line64="            this.overlapCheckerImage = result" line65="            this.overlapCheckerImageCenterX = (this.right + this.left) / 2" line66="            this.overlapCheckerImageCenterY = (this.top + this.bottom) / 2" line67="        }" line68="" line69="        checkOverlap(candidate: Sprite) {" line70="            if (this.direction == LaserAttackDirection.RIGHT) {" line71="                if (candidate.x &lt; this.left) {" line72="                    return false;" line73="                } else {" line74="                    return this.top &lt; candidate.y &amp;&amp; candidate.y &lt; this.bottom" line75="                }" line76="            }" line77="            return false;" line78="        }" line79="" line80="" line81="        constructor() {" line82="            this.onHitCallbacks = []" line83="            this._init()" line84="        }" line85="" line86="" line87="        registerOnHitCallbacks(spriteKind: number, onHitCallback: (sprite: Sprite) =&gt; void) {" line88="            this.onHitCallbacks.push(new LaserAttackCallback(spriteKind, onHitCallback))" line89="        }" line90="" line91="        stop() {" line92="            this.active = false;" line93="        }" line94="" line95="" line96="        onUpdateListener() {" line97="            if (!this.active) {" line98="                return;" line99="            }" line100="" line101="            let attackSprites: Sprite[] = []" line102="" line103="            this.resetOverlapChecker()" line104="" line105="            for (let callback of this.onHitCallbacks) {" line106="                for (let candidate of sprites.allOfKind(callback.spriteKind)) {" line107="                    if (this.hitSprites.find((value:Sprite) =&gt; value === candidate)) {" line108="                        continue" line109="                    }" line110="" line111="                    if (candidate.flags &amp; (sprites.Flag.Ghost | sprites.Flag.RelativeToCamera)) {" line112="                        continue" line113="                    }" line114="" line115="                    if (this.checkOverlap(candidate)) {" line116="                        this.hitSprites.push(candidate)" line117="                        control.runInParallel(function () {" line118="                            callback.callback(candidate)" line119="                        })" line120="                    }" line121="                }" line122="                " line123="            }" line124="" line125="" line126="        }" line127="" line128="" line129="        _init() {" line130="            game.onUpdate(() =&gt; {" line131="                this.onUpdateListener()" line132="            })" line133="        }" line134="" line135="    }" line136="" line137="    class LaserAttackAnimation {" line138="        private static laserAttackAnimationBgImage: Image" line139="        private direction: LaserAttackDirection" line140="        private x: number" line141="        private y: number" line142="        private width: number" line143="        private active: boolean" line144="        private sprite: Sprite" line145="" line146="" line147="        constructor() {" line148="            this._init()" line149="        }" line150="" line151="" line152="        define(sprite: Sprite, width: number, direction: LaserAttackDirection) {" line153="            this.sprite = sprite" line154="            this.width = width" line155="            this.direction = direction" line156="            this.active = true" line157="        }" line158="" line159="        stopAnimation() {" line160="            this.active = false;" line161="            this.clearEffect()" line162="        }" line163="" line164="" line165="        public static _init = (() =&gt; {" line166="            if (!LaserAttackAnimation.laserAttackAnimationBgImage) {" line167="                LaserAttackAnimation.laserAttackAnimationBgImage = image.create(160, 120)" line168="                scene.addBackgroundLayer(LaserAttackAnimation.laserAttackAnimationBgImage, 100, BackgroundAlignment.Left)" line169="            }" line170="            return true;" line171="        })()" line172="" line173="        clearEffect() {" line174="            LaserAttackAnimation.laserAttackAnimationBgImage.fill(0)" line175="        }" line176="" line177="        _init() {" line178="            game.onPaint(() =&gt; {" line179="                this.onPaintListener()" line180="            })" line181="        }" line182="" line183="        draw() {" line184="            this.clearEffect()" line185="" line186="            LaserAttackAnimation.laserAttackAnimationBgImage.fillCircle(this.x, this.y, this.width, COLOR_OUTER)" line187="            switch (this.direction) {" line188="                case LaserAttackDirection.RIGHT:" line189="                    LaserAttackAnimation.laserAttackAnimationBgImage.fillRect(this.x, this.y - this.width / 2, 160 - this.x, this.width, COLOR_OUTER)" line190="                    LaserAttackAnimation.laserAttackAnimationBgImage.fillRect(this.x, this.y - this.width / 4, 160 - this.x, this.width / 2, COLOR_INNER)" line191="            }" line192="            LaserAttackAnimation.laserAttackAnimationBgImage.fillCircle(this.x, this.y, this.width / 2, COLOR_INNER)" line193="        }" line194="" line195="        onPaintListener() {" line196="            if (this.active) {" line197="                this.x = this.sprite.x" line198="                this.y = this.sprite.y" line199="                this.draw()" line200="            }" line201="        }" line202="    }" line203="" line204="    let checker = new LaserAttackChecker()" line205="    let laserAttackAnimation = new LaserAttackAnimation()" line206="    let laserAttackCallbacks: LaserAttackCallback[] = []" line207="" line208="" line209="    //% blockId=launch_laser_attack" line210="    //% block=&quot;launch laser attack from %sprite=variables_get(mySprite) to %direction=direction by %width for %duration=timePicker|ms&quot;" line211="     //% width.defl=40 duration.defl=1000 direction.defl= LaserAttackDirection.RIGHT" line212="    //% group=&quot;Attack&quot;" line213="    export function laserAttack(sprite: Sprite, direction: LaserAttackDirection," line214="        width: number, duration: number) {" line215="" line216="        checker.define(sprite, width, direction)" line217="        laserAttackAnimation.define(sprite, width, direction)" line218="" line219="        control.runInParallel(function () {" line220="            pause(duration)" line221="            checker.stop()" line222="            laserAttackAnimation.stopAnimation()" line223="        })" line224="    }" line225="" line226="" line227="" line228="    //% blockId=on_laser_hit" line229="    //% group=&quot;Attack&quot;" line230="    //% block=&quot;on laser hits of %spriteKind=spritekind&quot;" line231="    //% draggableParameters=&quot;sprite&quot;" line232="    export function onLaserHit(spriteKind: number, spriteHitCallback: (sprite: Sprite) =&gt; void) {" line233="        checker.registerOnHitCallbacks(spriteKind, spriteHitCallback)" line234="    }" line235="" line236="}" numlines="237"></mutation><comment id="undefined" pinned="false" h="80" w="160">% weight=100 color=#6699CC icon="\u2593" block="SpecialAttack" % groups='["Attack"]'</comment></block></statement></block></xml>